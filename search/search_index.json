{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"KYCC \u2014 Know Your Customer's Customer","text":""},{"location":"#overview","title":"Overview","text":"<p>KYCC is an enterprise-grade supply chain intelligence and credit scoring platform. It models companies (parties), their relationships, transactions, and automatically computes creditworthiness scores using a feature-based scorecard model.</p>"},{"location":"#what-the-system-does","title":"What the System Does","text":"<ol> <li>Stores supply chain data: Parties (suppliers, manufacturers, distributors, retailers), relationships between them, and transaction history</li> <li>Extracts features: Automatically derives meaningful financial and network signals from raw data (KYC scores, transaction counts, network depth, etc.)</li> <li>Computes credit scores: Applies a weighted scorecard model to produce 300-900 credit scores (FICO-like standard)</li> <li>Applies business rules: Enforces decision rules (approve/reject/flag/manual review) based on scores and features</li> <li>Audits everything: Logs all scoring requests with full feature snapshots for complete explainability and compliance</li> </ol>"},{"location":"#key-technologies","title":"Key Technologies","text":"Layer Technology Purpose API FastAPI + Python 3.11 REST API with 23 endpoints, async, auto-generated docs Database PostgreSQL 15 + SQLAlchemy 2.x Relational data, ORM, temporal features, JSON support Validation Pydantic v2 Type-safe API schemas, ORM integration Frontend React (esbuild) Interactive web UI, visualizations Alternative UI Streamlit Lightweight testing UI, rapid prototyping"},{"location":"#tech-stack-rationale","title":"Tech Stack Rationale","text":"<ul> <li>FastAPI: Type hints, async support, auto-generated OpenAPI docs, integration with Pydantic</li> <li>SQLAlchemy 2.x: Modern async support, clear ORM relationships, session management, query builder</li> <li>PostgreSQL: Native JSON support (for feature snapshots), recursive CTEs (for graph traversal), ACID guarantees</li> <li>Pydantic v2: Strict validation, ORM mode for automatic conversion, field aliases and custom namespaces</li> <li>React: Component-based, state management, D3/Plotly for visualizations</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":""},{"location":"#high-level-data-flow","title":"High-Level Data Flow","text":"<pre><code>User Request (Frontend or API)\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  FastAPI REST API (main.py)         \u2502\n\u2502  - 23 routes across 3 routers       \u2502\n\u2502  - CORS enabled for localhost       \u2502\n\u2502  - Pydantic validation              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Scoring Service                    \u2502\n\u2502  (app/services/scoring_service.py)  \u2502\n\u2502  1. Trigger feature extraction      \u2502\n\u2502  2. Fetch scoring model             \u2502\n\u2502  3. Apply scorecard algorithm       \u2502\n\u2502  4. Apply decision rules            \u2502\n\u2502  5. Generate audit log              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Feature Pipeline Service           \u2502\n\u2502  (app/services/feature_pipeline...) \u2502\n\u2502  Orchestrates 3 extractors:         \u2502\n\u2502  - KYC Extractor (Party table)      \u2502\n\u2502  - Transaction Extractor (Txn hist) \u2502\n\u2502  - Network Extractor (Relationships)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  SQLAlchemy ORM Layer               \u2502\n\u2502  - Reads: Party, Transaction, Rel.  \u2502\n\u2502  - Writes: features, score_requests \u2502\n\u2502  - Session management + pooling     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2193\nPostgreSQL 15 (Primary) or SQLite (Fallback)\n        \u2193\nResponse \u2192 Serialized JSON \u2192 Frontend Display\n</code></pre>"},{"location":"#component-interaction-map","title":"Component Interaction Map","text":"Component Depends On Provides When Called FastAPI Router Database, Scoring Service HTTP JSON response Client calls <code>/api/scoring/score/{id}</code> Scoring Service Feature Pipeline, Model Registry, Decision Rules Credit score + decision + audit log Router calls <code>compute_score(party_id)</code> Feature Pipeline 3 Extractors, Database Feature dictionary Scoring Service calls <code>_ensure_features_exist()</code> KYC Extractor Party table <code>{kyc_score, company_age_days, party_type_encoded, ...}</code> Pipeline calls <code>.extract(party_id, db)</code> Transaction Extractor Transaction table <code>{transaction_count, avg_amount, regularity, recency}</code> Pipeline calls <code>.extract(party_id, db)</code> Network Extractor Relationship table <code>{network_size, counterparty_count, network_depth}</code> Pipeline calls <code>.extract(party_id, db)</code> Model Registry Database (SELECT) Active scorecard weights + intercept Scoring Service queries during compute Decision Rules Database (SELECT) Rule conditions + actions Scoring Service evaluates after score Feature Storage Database (INSERT/UPDATE) Versioned features with valid_from/valid_to Pipeline calls <code>_store_features()</code>"},{"location":"#core-scoring-logic","title":"Core Scoring Logic","text":""},{"location":"#1-feature-extraction-parallel-multi-source","title":"1. Feature Extraction (Parallel, Multi-Source)","text":"<p>Purpose: Convert raw company data into normalized numerical features suitable for credit scoring.</p> <p>Three extractors run in parallel and are combined:</p>"},{"location":"#kyc-extractor","title":"KYC Extractor","text":"<pre><code># Reads from: parties table\n\nfeatures = {\n  \"kyc_score\": 85,                    # from Party.kyc_verified (0-100)\n  \"company_age_days\": 180,            # days since Party.created_at\n  \"party_type_encoded\": 1,            # numeric encoding: supplier=1, mfg=2, etc.\n  \"contact_completeness\": 75          # % of contact fields filled\n}\n</code></pre> <p>Why these features? - KYC score: Indicator of compliance and due diligence completion - Company age: Older = more established (lower risk) - Party type: Some types considered inherently lower risk - Contact completeness: Better data quality = lower risk</p>"},{"location":"#transaction-extractor","title":"Transaction Extractor","text":"<pre><code># Reads from: transactions table (filtered by party_id)\n\nfeatures = {\n  \"transaction_count\": 15,            # total txns in history\n  \"avg_transaction_amount\": 5000,     # mean transaction value ($)\n  \"transaction_regularity\": 0.96,     # 1 - (std_dev / mean), high = consistent\n  \"days_since_last_transaction\": 2    # recency (lower = more active)\n}\n</code></pre> <p>Why these features? - Volume: More transactions = longer business history - Consistency: Regular txns indicate stable, predictable business - Recency: Recent activity = company is currently operating</p>"},{"location":"#network-extractor","title":"Network Extractor","text":"<pre><code># Reads from: relationships table (graph traversal)\n\nfeatures = {\n  \"network_size\": 2,                  # total distinct parties in component\n  \"counterparty_count\": 1,            # immediate neighbors (suppliers + customers)\n  \"network_depth\": 2                  # max hops in relationship graph\n}\n</code></pre> <p>Why these features? - Network size: Larger supply chains indicate established position - Counterparty count: Diversified customer/supplier base = lower concentration risk - Network depth: Deep integration in supply chain = important player</p>"},{"location":"#feature-versioning-temporal-validity","title":"Feature Versioning (Temporal Validity)","text":"<pre><code>-- Storage model in features table:\nparty_id: 1\nfeature_name: \"kyc_score\"\nfeature_value: 85.0\nsource_type: \"KYC\"\nvalid_from: 2025-12-12T10:30:00\nvalid_to: NULL                -- NULL = current version (active)\n\n-- When re-computed 7 days later:\n-- UPDATE old record: valid_to = 2025-12-19T10:30:00 (mark as expired)\n-- INSERT new record: valid_from = 2025-12-19T10:30:00, valid_to = NULL\n\n-- Benefits:\n-- \u2705 Historical audit: can replay old scores with old features\n-- \u2705 Debugging: compare how feature values changed over time\n-- \u2705 Rollback: revert to old features if extraction logic was wrong\n</code></pre>"},{"location":"#2-scorecard-scoring-algorithm-weighted-linear-model","title":"2. Scorecard Scoring Algorithm (Weighted Linear Model)","text":"<p>Algorithm: <code>score = intercept + \u03a3(normalized_feature[i] \u00d7 weight[i])</code></p> <p>Step 1: Normalize Features (0-1 Scale)</p> <p>Raw features come in different units (days, dollars, counts, percentages). Normalize using min-max scaling:</p> <pre><code>normalized = (value - min) / (max - min)\n\nExamples:\n  kyc_score: 85 \u2192 0.85 (divide by 100)\n  company_age_days: 180 \u2192 0.49 (assume max ~365)\n  transaction_count: 15 \u2192 0.75 (assume max ~20)\n  transaction_regularity: 0.96 \u2192 0.96 (already in 0-1 range)\n</code></pre> <p>Step 2: Fetch Model from model_registry</p> <pre><code>SELECT model_version, model_config, feature_list, intercept\nFROM model_registry\nWHERE is_active = 1\nORDER BY deployed_date DESC\nLIMIT 1;\n\n-- Returns:\n{\n  \"model_version\": \"default_scorecard_v1\",\n  \"intercept\": 0.0,\n  \"weights\": {\n    \"kyc_score\": 0.20,\n    \"company_age_days\": 0.10,\n    \"transaction_count\": 0.25,\n    \"transaction_regularity\": 0.15,\n    \"days_since_last_transaction\": 0.10,\n    \"network_size\": 0.10,\n    \"counterparty_count\": 0.05\n  }\n}\n</code></pre> <p>Step 3: Apply Weighted Sum</p> <pre><code>score_0_to_1 = intercept\nscore_0_to_1 += 0.85 * 0.20    # kyc_score: 0.17\nscore_0_to_1 += 0.49 * 0.10    # company_age: 0.049\nscore_0_to_1 += 0.75 * 0.25    # transaction_count: 0.1875\nscore_0_to_1 += 0.96 * 0.15    # regularity: 0.144\nscore_0_to_1 += 0.99 * 0.10    # recency: 0.099\nscore_0_to_1 += 0.33 * 0.10    # network_size: 0.033\nscore_0_to_1 += 0.25 * 0.05    # counterparty: 0.0125\n# = 0.769 (on 0-1 scale)\n</code></pre> <p>Step 4: Scale to 300-900 Range (FICO-like)</p> <p>Why 300-900? Industry standard for credit scores (FICO, VantageScore). Makes scores interpretable to domain experts.</p> <pre><code>final_score = 300 + (score_0_to_1 \u00d7 600)\n            = 300 + (0.769 \u00d7 600)\n            = 300 + 461.4\n            = 761 \u2713\n</code></pre> <p>Step 5: Assign Score Band</p> <pre><code>if final_score &gt;= 800:\n    band = \"excellent\"\nelif final_score &gt;= 650:\n    band = \"good\"          \u2190 761 falls here\nelif final_score &gt;= 550:\n    band = \"fair\"\nelse:\n    band = \"poor\"\n</code></pre> <p>Step 6: Compute Confidence</p> <pre><code>confidence = count(available_features) / total_expected_features\n           = 8 / 15 = 0.53\n\n# Higher confidence = more features were available for scoring\n</code></pre> <p>Why Linear Scorecard? - \u2705 Interpretable: Easy to explain which features drive score - \u2705 Fast: O(n) computation (fast even with many features) - \u2705 Auditable: Weights stored in database, versioned - \u2705 ML-Ready: Scorecard is a special case of logistic regression (can swap in ML later) - \u2705 Regulatory: Easier to comply with explainability requirements</p>"},{"location":"#3-decision-rules-engine","title":"3. Decision Rules Engine","text":"<p>Purpose: Apply business rules on top of the raw score to produce final decision.</p>"},{"location":"#rule-structure","title":"Rule Structure","text":"<pre><code>class DecisionRule:\n    rule_id: str                  # \"RULE_001\"\n    rule_name: str                # \"Reject low KYC\"\n    condition_expression: str     # Python expression: \"kyc_score &lt; 50\"\n    action: str                   # \"reject\" | \"flag\" | \"manual_review\" | \"approve\"\n    priority: int                 # 1=highest (first match wins)\n    is_active: bool               # only evaluate active rules\n</code></pre>"},{"location":"#evaluation-logic","title":"Evaluation Logic","text":"<pre><code>def apply_decision_rules(features: dict) -&gt; (decision, reasons):\n    rules = db.query(DecisionRule)\\\n        .filter(DecisionRule.is_active.in_([1, True]))\\\n        .order_by(DecisionRule.priority)\\\n        .all()\n\n    for rule in rules:\n        try:\n            # Build safe evaluation context (no builtins)\n            safe_context = {\"__builtins__\": {}}\n            safe_context.update(features)\n\n            # Evaluate rule condition with feature values\n            if eval(rule.condition_expression, safe_context):\n                return rule.action, [rule.rule_name]\n        except Exception:\n            # Skip rules that fail to evaluate\n            pass\n\n    # Default if no rules matched\n    return \"approved\", []\n</code></pre>"},{"location":"#example-decision-rules","title":"Example Decision Rules","text":"Priority Condition Action Reason 1 <code>transaction_count == 0</code> reject No transaction history = cannot assess 2 <code>kyc_score &lt; 40</code> reject Very poor KYC verification 3 <code>network_size &lt; 2</code> flag Isolated in supply chain (risky) 4 <code>company_age_days &lt; 30</code> manual_review Too new to assess 5 <code>final_score &gt; 800</code> approve Excellent creditworthiness"},{"location":"#safety-notes","title":"Safety Notes","text":"<ul> <li>Only <code>__builtins__</code> removed (no <code>open()</code>, <code>exec()</code>, <code>import</code>)</li> <li>Features dict provides variable context</li> <li>Failed expressions skip silently (don't break entire scoring)</li> <li>Production: Use expression parser like <code>simpleeval</code> instead of <code>eval()</code></li> </ul>"},{"location":"#4-audit-logging-complete-traceability","title":"4. Audit Logging (Complete Traceability)","text":"<p>Every score computation creates a ScoreRequest record:</p> <pre><code>class ScoreRequest:\n    id: str                          # UUID\n    party_id: int                    # Which company?\n    request_timestamp: datetime      # When scored\n    model_version: str               # \"default_scorecard_v1\"\n    model_type: str                  # \"scorecard\" | \"ml_model\"\n    features_snapshot: JSON          # All features used (for replay)\n    raw_score: float                 # 0-1\n    final_score: int                 # 300-900\n    score_band: str                  # excellent/good/fair/poor\n    confidence_level: float          # % of available features\n    decision: str                    # approve/reject/flag/review\n    decision_reasons: JSON           # [rule names that matched]\n    processing_time_ms: int\n</code></pre> <p>Benefits: - \u2705 Explainability: Show user \"these features were used at score time\" - \u2705 Audit Trail: When was company scored? By which model? - \u2705 Replay: If model weights change, re-run old scores with old features - \u2705 Debugging: If score seems wrong, check features_snapshot - \u2705 Compliance: Full traceability for regulatory reviews</p> <p>Example Snapshot:</p> <pre><code>{\n  \"kyc_score\": 85,\n  \"company_age_days\": 180,\n  \"party_type_encoded\": 1,\n  \"contact_completeness\": 75,\n  \"transaction_count\": 15,\n  \"avg_transaction_amount\": 5000,\n  \"transaction_regularity\": 0.96,\n  \"days_since_last_transaction\": 2,\n  \"network_size\": 2,\n  \"counterparty_count\": 1,\n  \"network_depth\": 2\n}\n</code></pre>"},{"location":"#complete-example-scoring-three-companies","title":"Complete Example: Scoring Three Companies","text":""},{"location":"#setup-three-test-parties-in-supply-chain","title":"Setup: Three Test Parties in Supply Chain","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  SUPPLY CHAIN NETWORK                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                         \u2502\n\u2502  Party 1: ACME SUPPLIERS (supplier)                    \u2502\n\u2502    \u251c\u2500 Created: 180 days ago                            \u2502\n\u2502    \u251c\u2500 KYC Score: 85/100                                \u2502\n\u2502    \u251c\u2500 Transactions: 15 to Global Distributor           \u2502\n\u2502    \u2502   - Avg: $5,000 each                              \u2502\n\u2502    \u2502   - Regularity: Very consistent (std_dev: $200)   \u2502\n\u2502    \u2502   - Latest: 2 days ago                            \u2502\n\u2502    \u2514\u2500 Network: 1 direct customer (Global)              \u2502\n\u2502                                                         \u2502\n\u2502  \u2193 supplies_to                                          \u2502\n\u2502                                                         \u2502\n\u2502  Party 2: GLOBAL DISTRIBUTOR (distributor)             \u2502\n\u2502    \u251c\u2500 Created: 200 days ago                            \u2502\n\u2502    \u251c\u2500 KYC Score: 92/100                                \u2502\n\u2502    \u251c\u2500 Transactions: 8 to Local Retailer                \u2502\n\u2502    \u2502   - Avg: $3,000 each                              \u2502\n\u2502    \u2502   - Regularity: Somewhat irregular (std_dev: $1.5k)\n\u2502    \u2502   - Latest: 5 days ago                            \u2502\n\u2502    \u251c\u2500 Upstream: 1 supplier (ACME)                      \u2502\n\u2502    \u2514\u2500 Downstream: 1 customer (Local Retailer)          \u2502\n\u2502                                                         \u2502\n\u2502  \u2193 distributes_to                                       \u2502\n\u2502                                                         \u2502\n\u2502  Party 3: LOCAL RETAILER (retailer)                    \u2502\n\u2502    \u251c\u2500 Created: 30 days ago                             \u2502\n\u2502    \u251c\u2500 KYC Score: 60/100                                \u2502\n\u2502    \u251c\u2500 Transactions: 2 total                            \u2502\n\u2502    \u2502   - Avg: $500 each                                \u2502\n\u2502    \u2502   - Regularity: Very irregular                    \u2502\n\u2502    \u2502   - Latest: 1 day ago (recent)                    \u2502\n\u2502    \u2514\u2500 Upstream: 1 supplier (Global)                    \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#step-by-step-computing-score-for-acme-suppliers-party-1","title":"Step-by-Step: Computing Score for ACME SUPPLIERS (Party 1)","text":""},{"location":"#step-1-user-clicks-compute-credit-score-in-frontend","title":"Step 1: User Clicks \"Compute Credit Score\" in Frontend","text":"<pre><code>// React component\nonClick={() =&gt; fetch(\n  `http://localhost:8001/api/scoring/score/1`,\n  { method: 'POST', headers: { 'Content-Type': 'application/json' } }\n)}\n</code></pre>"},{"location":"#step-2-api-receives-request","title":"Step 2: API Receives Request","text":"<pre><code># app/api/scoring.py\n@router.post(\"/api/scoring/score/{party_id}\")\ndef get_credit_score(\n    party_id: int,\n    model_version: Optional[str] = None,\n    include_explanation: bool = True,\n    db: Session = Depends(get_db)\n) \u2192 ScoreResponse:\n    scoring_service = ScoringService(db)\n    result = scoring_service.compute_score(party_id=1)\n    return result  # JSON serialized by Pydantic\n</code></pre>"},{"location":"#step-3-scoring-service-ensures-features-are-fresh","title":"Step 3: Scoring Service Ensures Features Are Fresh","text":"<pre><code># app/services/scoring_service.py\n\ndef compute_score(self, party_id: int):\n    # Check if features already computed and not stale (&lt; 7 days)\n    latest = db.query(Feature)\\\n        .filter(Feature.party_id == 1, Feature.valid_to == None)\\\n        .first()\n\n    if not latest or (datetime.utcnow() - latest.computation_timestamp).days &gt; 7:\n        # Trigger extraction\n        pipeline = FeaturePipelineService(db)\n        pipeline.extract_all_features(party_id=1)\n</code></pre>"},{"location":"#step-4-feature-pipeline-orchestrates-extraction","title":"Step 4: Feature Pipeline Orchestrates Extraction","text":"<pre><code># Three extractors run in parallel context:\n\nKYC_EXTRACTOR.extract(party_id=1, db):\n  party = db.query(Party).filter(Party.id == 1).first()  # ACME SUPPLIERS\n  return [\n    FeatureExtractorResult(\"kyc_score\", 85.0),\n    FeatureExtractorResult(\"company_age_days\", 180.0),\n    FeatureExtractorResult(\"party_type_encoded\", 1.0),    # supplier=1\n    FeatureExtractorResult(\"contact_completeness\", 75.0)\n  ]\n\nTRANSACTION_EXTRACTOR.extract(party_id=1, db):\n  txns = db.query(Transaction).filter(Transaction.from_party_id == 1).all()\n  # 15 transactions to Global Distributor\n  return [\n    FeatureExtractorResult(\"transaction_count\", 15.0),\n    FeatureExtractorResult(\"avg_transaction_amount\", 5000.0),\n    FeatureExtractorResult(\"transaction_regularity\", 0.96),  # very consistent\n    FeatureExtractorResult(\"days_since_last_transaction\", 2.0)\n  ]\n\nNETWORK_EXTRACTOR.extract(party_id=1, db):\n  # Graph traversal: ACME \u2192 Global \u2192 Local\n  # ACME has 1 direct customer (Global)\n  return [\n    FeatureExtractorResult(\"network_size\", 2.0),           # ACME + Global\n    FeatureExtractorResult(\"counterparty_count\", 1.0),     # 1 direct customer\n    FeatureExtractorResult(\"network_depth\", 2.0)           # 2 hops downstream\n  ]\n</code></pre>"},{"location":"#step-5-store-features-in-database-versioned","title":"Step 5: Store Features in Database (Versioned)","text":"<pre><code>INSERT INTO features (party_id, feature_name, feature_value, source_type, valid_from)\nVALUES\n  (1, 'kyc_score', 85.0, 'KYC', 2025-12-12 10:30:00),\n  (1, 'company_age_days', 180.0, 'KYC', 2025-12-12 10:30:00),\n  (1, 'party_type_encoded', 1.0, 'KYC', 2025-12-12 10:30:00),\n  (1, 'contact_completeness', 75.0, 'KYC', 2025-12-12 10:30:00),\n  (1, 'transaction_count', 15.0, 'TRANSACTION', 2025-12-12 10:30:00),\n  (1, 'avg_transaction_amount', 5000.0, 'TRANSACTION', 2025-12-12 10:30:00),\n  (1, 'transaction_regularity', 0.96, 'TRANSACTION', 2025-12-12 10:30:00),\n  (1, 'days_since_last_transaction', 2.0, 'TRANSACTION', 2025-12-12 10:30:00),\n  (1, 'network_size', 2.0, 'NETWORK', 2025-12-12 10:30:00),\n  (1, 'counterparty_count', 1.0, 'NETWORK', 2025-12-12 10:30:00),\n  (1, 'network_depth', 2.0, 'NETWORK', 2025-12-12 10:30:00);\n</code></pre>"},{"location":"#step-6-normalize-features-to-0-1-scale","title":"Step 6: Normalize Features to 0-1 Scale","text":"<pre><code>normalized_features = {\n    'kyc_score': 85.0 / 100.0 = 0.85,\n    'company_age_days': 180.0 / 365.0 = 0.49,\n    'party_type_encoded': 1.0 / 5.0 = 0.20,\n    'contact_completeness': 75.0 / 100.0 = 0.75,\n    'transaction_count': 15.0 / 20.0 = 0.75,\n    'avg_transaction_amount': 5000.0 / 7500.0 = 0.67,\n    'transaction_regularity': 0.96,\n    'days_since_last_transaction': (365.0 - 2.0) / 365.0 = 0.99,\n    'network_size': 2.0 / 6.0 = 0.33,\n    'counterparty_count': 1.0 / 4.0 = 0.25,\n    'network_depth': 2.0 / 3.0 = 0.67\n}\n</code></pre>"},{"location":"#step-7-fetch-scorecard-model","title":"Step 7: Fetch Scorecard Model","text":"<pre><code>SELECT * FROM model_registry\nWHERE is_active = 1\nORDER BY deployed_date DESC\nLIMIT 1;\n\n-- Returns:\n{\n  model_version: \"default_scorecard_v1\",\n  model_type: \"scorecard\",\n  is_active: 1,\n  intercept: 0.0,\n  weights: {\n    \"kyc_score\": 0.20,\n    \"company_age_days\": 0.10,\n    \"party_type_encoded\": 0.05,\n    \"contact_completeness\": 0.00,\n    \"transaction_count\": 0.25,\n    \"avg_transaction_amount\": 0.05,\n    \"transaction_regularity\": 0.15,\n    \"days_since_last_transaction\": 0.10,\n    \"network_size\": 0.10,\n    \"counterparty_count\": 0.05,\n    \"network_depth\": 0.00\n  }\n}\n</code></pre>"},{"location":"#step-8-apply-scorecard-formula-weighted-sum","title":"Step 8: Apply Scorecard Formula (Weighted Sum)","text":"<pre><code>score_0_to_1 = 0.0  # intercept\n\n# Apply each feature weight\nscore_0_to_1 += 0.85 * 0.20       # kyc_score = 0.170\nscore_0_to_1 += 0.49 * 0.10       # company_age = 0.049\nscore_0_to_1 += 0.20 * 0.05       # party_type = 0.010\nscore_0_to_1 += 0.75 * 0.00       # contact = 0.000\nscore_0_to_1 += 0.75 * 0.25       # transaction_count = 0.1875\nscore_0_to_1 += 0.67 * 0.05       # avg_amount = 0.0335\nscore_0_to_1 += 0.96 * 0.15       # regularity = 0.144\nscore_0_to_1 += 0.99 * 0.10       # recency = 0.099\nscore_0_to_1 += 0.33 * 0.10       # network_size = 0.033\nscore_0_to_1 += 0.25 * 0.05       # counterparty = 0.0125\nscore_0_to_1 += 0.67 * 0.00       # network_depth = 0.000\n\n# Total: 0.769 (on 0-1 scale)\n</code></pre>"},{"location":"#step-9-scale-to-credit-score-range-300-900","title":"Step 9: Scale to Credit Score Range (300-900)","text":"<pre><code>final_score = 300 + (0.769 * 600)\n            = 300 + 461.4\n            = 761 \u2713\n\nscore_band = \"good\" (650-800 range)\nconfidence = 10 / 11 = 0.91 (10 features used, 11 defined)\n</code></pre>"},{"location":"#step-10-apply-decision-rules","title":"Step 10: Apply Decision Rules","text":"<pre><code>SELECT * FROM decision_rules\nWHERE is_active = 1\nORDER BY priority;\n\n-- Evaluation:\n\nRule 1 (Priority 1): \"Reject if no transactions\"\n  Condition: transaction_count == 0\n  Eval: 15 == 0? NO \u2192 skip\n\nRule 2 (Priority 2): \"Reject if kyc_score &lt; 40\"\n  Condition: kyc_score &lt; 40\n  Eval: 85 &lt; 40? NO \u2192 skip\n\nRule 3 (Priority 3): \"Flag if network_size &lt; 2\"\n  Condition: network_size &lt; 2\n  Eval: 2 &lt; 2? NO \u2192 skip\n\nRule 4 (Priority 4): \"Approve if final_score &gt; 750\"\n  Condition: final_score &gt; 750\n  Eval: 761 &gt; 750? YES \u2713 \u2192 MATCH!\n\nFinal Decision: APPROVE\nReasons: [\"Rule 4: Approve if final_score &gt; 750\"]\n</code></pre>"},{"location":"#step-11-create-audit-log","title":"Step 11: Create Audit Log","text":"<pre><code>score_request = ScoreRequest(\n    id=\"550e8400-e29b-41d4-a716-446655440000\",  # UUID\n    party_id=1,\n    model_version=\"default_scorecard_v1\",\n    model_type=\"scorecard\",\n    features_snapshot=json.dumps({\n        \"kyc_score\": 85.0,\n        \"company_age_days\": 180.0,\n        \"party_type_encoded\": 1.0,\n        \"contact_completeness\": 75.0,\n        \"transaction_count\": 15.0,\n        \"avg_transaction_amount\": 5000.0,\n        \"transaction_regularity\": 0.96,\n        \"days_since_last_transaction\": 2.0,\n        \"network_size\": 2.0,\n        \"counterparty_count\": 1.0,\n        \"network_depth\": 2.0\n    }),\n    raw_score=0.769,\n    final_score=761,\n    score_band=\"good\",\n    confidence_level=0.91,\n    decision=\"APPROVE\",\n    decision_reasons=json.dumps([\n        \"Rule 4: Approve if final_score &gt; 750\"\n    ]),\n    processing_time_ms=145,\n    request_timestamp=datetime.utcnow()\n)\ndb.add(score_request)\ndb.commit()\n</code></pre>"},{"location":"#step-12-return-response-to-api","title":"Step 12: Return Response to API","text":"<pre><code>{\n  \"party_id\": 1,\n  \"score\": 761,\n  \"score_band\": \"good\",\n  \"confidence\": 0.91,\n  \"decision\": \"APPROVE\",\n  \"decision_reasons\": [\n    \"Rule 4: Approve if final_score &gt; 750\"\n  ],\n  \"explanation\": {\n    \"top_positive_factors\": [\n      {\n        \"feature\": \"transaction_count\",\n        \"value\": 15.0,\n        \"contribution\": 0.1875\n      },\n      {\n        \"feature\": \"transaction_regularity\",\n        \"value\": 0.96,\n        \"contribution\": 0.144\n      },\n      {\n        \"feature\": \"kyc_score\",\n        \"value\": 85.0,\n        \"contribution\": 0.170\n      }\n    ],\n    \"top_negative_factors\": []\n  },\n  \"computed_at\": \"2025-12-12T10:31:00\",\n  \"model_version\": \"default_scorecard_v1\"\n}\n</code></pre>"},{"location":"#step-13-frontend-displays-results","title":"Step 13: Frontend Displays Results","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  ACME SUPPLIERS - Credit Assessment   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                        \u2502\n\u2502        Credit Score: 761               \u2502\n\u2502        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 66%        \u2502\n\u2502                                        \u2502\n\u2502  Band: GOOD                            \u2502\n\u2502  Decision: \u2705 APPROVE                  \u2502\n\u2502  Confidence: 91%                       \u2502\n\u2502                                        \u2502\n\u2502  Scoring Breakdown:                    \u2502\n\u2502  \u2022 Transaction Count:      +0.1875     \u2502\n\u2502  \u2022 Regularity:             +0.144      \u2502\n\u2502  \u2022 KYC Score:              +0.170      \u2502\n\u2502  \u2022 Days Since Last Txn:    +0.099      \u2502\n\u2502  \u2022 Company Age:            +0.049      \u2502\n\u2502  \u2022 Network Size:           +0.033      \u2502\n\u2502  \u2022 Counterparty Count:     +0.0125     \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  Total (Raw): 0.769 \u2192 Final: 761       \u2502\n\u2502                                        \u2502\n\u2502  Rules Applied:                        \u2502\n\u2502  \u2713 Rule 4: Approve if score &gt; 750      \u2502\n\u2502                                        \u2502\n\u2502  Computed: 2025-12-12 10:31:00         \u2502\n\u2502  Model: default_scorecard_v1           \u2502\n\u2502  Processing Time: 145ms                \u2502\n\u2502                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#summary-table-all-three-companies","title":"Summary Table: All Three Companies","text":"Company KYC Age Txns Regularity Score Band Decision ACME Suppliers (ID=1) 85 180d 15 0.96 761 GOOD \u2705 APPROVE Global Distributor (ID=2) 92 200d 8 0.70 748 GOOD \u26a0\ufe0f REVIEW Local Retailer (ID=3) 60 30d 2 0.40 425 POOR \u274c REJECT <p>Why Different Decisions?</p> <ul> <li>ACME (761): High KYC, consistent transactions, established history \u2192 APPROVE</li> <li>Global Distributor (748): High KYC but borderline score (748 vs 750 threshold) \u2192 requires MANUAL REVIEW</li> <li>Local Retailer (425): New company, low KYC, few transactions, isolation in network \u2192 REJECT per Rule 1</li> </ul>"},{"location":"#project-structure-components","title":"Project Structure &amp; Components","text":""},{"location":"#directory-layout","title":"Directory Layout","text":"<pre><code>KYCC/\n\u251c\u2500\u2500 backend/                           # FastAPI server\n\u2502   \u251c\u2500\u2500 __init__.py                   # Makes backend a package\n\u2502   \u251c\u2500\u2500 main.py                       # FastAPI app + 3 routers + health/stats\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 db/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 database.py           # Engine, SessionLocal, get_db()\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 crud.py               # Create/read/update/delete helpers\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 models.py             # 14 SQLAlchemy ORM models\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 schemas.py            # Pydantic validation schemas\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 parties.py            # /api/parties/* endpoints\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 relationships.py      # /api/relationships/* endpoints\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 scoring.py            # /api/scoring/* endpoints (\u2605 MAIN)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 scoring_service.py    # Orchestrates scoring pipeline\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 feature_pipeline_service.py  # Orchestrates feature extraction\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 network_service.py    # Graph traversal for relationships\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 extractors/\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u251c\u2500\u2500 base_extractor.py     # BaseFeatureExtractor + FeatureExtractorResult\n\u2502   \u2502       \u251c\u2500\u2500 kyc_extractor.py      # KYC features from parties table\n\u2502   \u2502       \u251c\u2500\u2500 transaction_extractor.py  # Transaction features (volume, consistency)\n\u2502   \u2502       \u251c\u2500\u2500 network_extractor.py  # Network features (size, depth)\n\u2502       \u2502   \u2514\u2500\u2500 __pycache__/\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 alembic/                       # Database migrations (future)\n\u2502   \u2502   \u251c\u2500\u2500 env.py\n\u2502   \u2502   \u251c\u2500\u2500 README\n\u2502   \u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2502   \u2514\u2500\u2500 versions/\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 .env                           # Environment config (DO NOT COMMIT)\n\u2502   \u251c\u2500\u2500 alembic.ini                    # Alembic config\n\u2502   \u251c\u2500\u2500 requirements.txt                # Python dependencies\n\u2502   \u2514\u2500\u2500 test_*.py / view_database.py   # Test scripts\n\u2502\n\u251c\u2500\u2500 frontend/                           # React + Streamlit UIs\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 PartyList.jsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 PartyForm.jsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 CreditScore.jsx       # Display scoring results (\u2605)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 NetworkGraph.jsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 FeatureBreakdown.jsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u251c\u2500\u2500 App.jsx                    # Main routing\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 streamlit_app.py               # Lightweight alternative UI\n\u2502   \u251c\u2500\u2500 package.json                   # Node dependencies\n\u2502   \u251c\u2500\u2500 esbuild.config.js             # Build configuration\n\u2502   \u2514\u2500\u2500 node_modules/\n\u2502\n\u251c\u2500\u2500 README.md                           # This file\n\u251c\u2500\u2500 .git/                               # Version control\n\u2514\u2500\u2500 .gitignore                          # Exclude .env, venv, etc.\n</code></pre>"},{"location":"#database-schema-logical","title":"Database Schema (Logical)","text":""},{"location":"#core-tables","title":"Core Tables","text":""},{"location":"#parties-supply-chain-actors","title":"<code>parties</code> (Supply Chain Actors)","text":"Column Type Notes id INT Primary key party_name VARCHAR Company name party_type VARCHAR supplier, manufacturer, distributor, retailer, customer kyc_verified INT 0-100 compliance score tax_id VARCHAR Tax identification address VARCHAR contact_person VARCHAR email VARCHAR phone VARCHAR created_at TIMESTAMP When registered updated_at TIMESTAMP Last modification"},{"location":"#relationships-supply-chain-connections","title":"<code>relationships</code> (Supply Chain Connections)","text":"Column Type Notes id INT Primary key from_party_id INT FK \u2192 parties to_party_id INT FK \u2192 parties relationship_type VARCHAR supplies_to, distributes_to, etc. created_at TIMESTAMP When created"},{"location":"#transactions-paymentshipment-history","title":"<code>transactions</code> (Payment/Shipment History)","text":"Column Type Notes id INT Primary key from_party_id INT FK \u2192 parties to_party_id INT FK \u2192 parties amount DECIMAL Transaction value transaction_date TIMESTAMP When occurred payment_type VARCHAR Cash, wire, crypto, etc. created_at TIMESTAMP"},{"location":"#scoring-features-tables","title":"Scoring &amp; Features Tables","text":""},{"location":"#features-extracted-signals-versioned","title":"<code>features</code> (Extracted Signals - Versioned)","text":"Column Type Notes id INT Primary key party_id INT FK \u2192 parties feature_name VARCHAR kyc_score, transaction_count, etc. feature_value DECIMAL Numerical value confidence_score DECIMAL 0-1, extractor confidence source_type VARCHAR KYC, TRANSACTION, NETWORK computation_timestamp TIMESTAMP When computed valid_from TIMESTAMP Start of validity valid_to TIMESTAMP End of validity (NULL = current) <p>Indices: - <code>(party_id, feature_name, valid_to)</code> - Fast lookup of current features</p>"},{"location":"#score_requests-audit-log-complete-traceability","title":"<code>score_requests</code> (Audit Log - Complete Traceability)","text":"Column Type Notes id VARCHAR UUID, primary key party_id INT FK \u2192 parties request_timestamp TIMESTAMP When scored model_version VARCHAR Scorecard ID model_type VARCHAR scorecard, ml_model features_snapshot JSON All features at scoring time raw_score DECIMAL 0-1 final_score INT 300-900 score_band VARCHAR excellent, good, fair, poor confidence_level DECIMAL 0-1 decision str approve, reject, flag, manual_review decision_reasons JSON Rule names that matched processing_time_ms INT Latency <p>Indices: - <code>(party_id)</code> - Lookup scores by company - <code>(request_timestamp DESC)</code> - Latest scores first</p>"},{"location":"#model_registry-scorecard-repository","title":"<code>model_registry</code> (Scorecard Repository)","text":"Column Type Notes model_version VARCHAR PK, e.g. \"default_scorecard_v1\" model_type VARCHAR scorecard, xgboost, neural_net model_config JSON Weights, intercept, hyperparams feature_list JSON [\"kyc_score\", \"transaction_count\", ...] intercept DECIMAL Offset for scorecard normalization_method VARCHAR min-max, z-score, etc. training_date TIMESTAMP When trained deployed_date TIMESTAMP When put in production is_active INT 0/1 (current model) performance_metrics JSON AUC, precision, recall, etc. description TEXT Notes created_by VARCHAR Model creator"},{"location":"#decision_rules-business-rules","title":"<code>decision_rules</code> (Business Rules)","text":"Column Type Notes rule_id VARCHAR PK, e.g. \"RULE_001\" rule_name VARCHAR Descriptive name condition_expression TEXT Python expression action VARCHAR approve, reject, flag, manual_review priority INT 1=highest (first match wins) is_active INT 0/1 (enable/disable) created_at TIMESTAMP updated_at TIMESTAMP"},{"location":"#api-endpoints-23-total","title":"API Endpoints (23 Total)","text":""},{"location":"#parties-crud-7-endpoints","title":"Parties CRUD (7 endpoints)","text":"<ul> <li><code>POST /api/parties/</code> \u2014 Create party</li> <li><code>GET /api/parties/</code> \u2014 List parties (filterable: <code>?party_type=supplier</code>)</li> <li><code>GET /api/parties/{id}</code> \u2014 Get one party</li> <li><code>PUT /api/parties/{id}</code> \u2014 Update party</li> <li><code>DELETE /api/parties/{id}</code> \u2014 Delete party</li> <li><code>GET /api/parties/{id}/network</code> \u2014 Get relationship graph (tree)</li> <li><code>GET /api/parties/{id}/counterparties</code> \u2014 Get direct neighbors only</li> </ul>"},{"location":"#relationships-crud-3-endpoints","title":"Relationships CRUD (3 endpoints)","text":"<ul> <li><code>POST /api/relationships/</code> \u2014 Create relationship</li> <li><code>GET /api/relationships/</code> \u2014 List relationships</li> <li><code>DELETE /api/relationships/{id}</code> \u2014 Remove relationship</li> </ul>"},{"location":"#scoring-4-endpoints","title":"Scoring \u2b50 (4 endpoints)","text":"<ul> <li><code>POST /api/scoring/score/{party_id}</code> \u2014 Compute credit score (MAIN)</li> <li><code>GET /api/scoring/score/{party_id}/history</code> \u2014 Score audit trail</li> <li><code>GET /api/scoring/features/{party_id}</code> \u2014 View extracted features</li> <li><code>POST /api/scoring/compute-features/{party_id}</code> \u2014 Manually trigger extraction</li> </ul>"},{"location":"#utility-3-endpoints","title":"Utility (3 endpoints)","text":"<ul> <li><code>GET /</code> \u2014 API info + endpoints list</li> <li><code>GET /health</code> \u2014 Health check</li> <li><code>GET /api/stats</code> \u2014 System statistics (party counts, avg scores, distributions)</li> </ul>"},{"location":"#setup-local-development","title":"Setup &amp; Local Development","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker Desktop (for PostgreSQL)</li> <li>Node.js 18+ (optional, for React frontend)</li> </ul>"},{"location":"#step-1-clone-create-virtual-environment","title":"Step 1: Clone &amp; Create Virtual Environment","text":"<pre><code># Clone repo\ngit clone &lt;repo&gt; &amp;&amp; cd KYCC\n\n# Create Python venv\npython -m venv venv\nvenv\\Scripts\\Activate.ps1  # Windows PowerShell\n\n# Install dependencies\npip install -r backend/requirements.txt\n</code></pre>"},{"location":"#step-2-start-postgresql","title":"Step 2: Start PostgreSQL","text":"<pre><code># Run Postgres container (persistent volume)\ndocker run -d --name kycc-postgres `\n  -e POSTGRES_USER=kycc_user `\n  -e POSTGRES_PASSWORD=kycc_pass `\n  -e POSTGRES_DB=kycc_db `\n  -p 5433:5432 `\n  -v kycc_pgdata:/var/lib/postgresql/data `\n  postgres:15\n\n# Verify ready\ndocker exec kycc-postgres pg_isready -U kycc_user -d kycc_db\n</code></pre>"},{"location":"#step-3-configure-env","title":"Step 3: Configure <code>.env</code>","text":"<pre><code># backend/.env\nDATABASE_URL=postgresql://kycc_user:kycc_pass@localhost:5433/kycc_db\nDEV_DATABASE_URL=sqlite:///./dev.db\nAUTO_CREATE_TABLES=1\nFORCE_SQLITE_FALLBACK=0\n</code></pre>"},{"location":"#step-4-run-api-server","title":"Step 4: Run API Server","text":"<pre><code>cd backend\npython -m uvicorn main:app --reload --port 8001\n\n# API available at:\n# - http://localhost:8001\n# - API docs: http://localhost:8001/docs\n# - ReDoc: http://localhost:8001/redoc\n</code></pre>"},{"location":"#step-5-run-frontend-optional","title":"Step 5: Run Frontend (Optional)","text":"<p>Option A: React (esbuild)</p> <pre><code>cd frontend\nnpm install &amp;&amp; npm run dev\n# Open http://localhost:5173\n</code></pre> <p>Option B: Streamlit (Lightweight)</p> <pre><code>cd frontend\npython -m streamlit run streamlit_app.py\n# Opens automatically in browser\n</code></pre>"},{"location":"#troubleshooting","title":"Troubleshooting","text":""},{"location":"#modulenotfounderror-no-module-named-app","title":"\"ModuleNotFoundError: No module named 'app'\"","text":"<p>Solution: Ensure <code>backend/__init__.py</code> exists (makes backend a package).</p>"},{"location":"#postgres-connection-error","title":"Postgres Connection Error","text":"<p>Solution: 1. Verify container running: <code>docker ps</code> 2. Check credentials in <code>.env</code> match Docker setup 3. Set <code>FORCE_SQLITE_FALLBACK=1</code> to use SQLite instead</p>"},{"location":"#score-seems-wrong","title":"Score Seems Wrong","text":"<p>Debug: 1. Call <code>GET /api/scoring/features/{party_id}</code> to see extracted features 2. Check <code>model_registry</code> table for correct weights 3. Review <code>score_requests</code> audit log entry for <code>features_snapshot</code></p>"},{"location":"#design-principles","title":"Design Principles","text":"<p>\u2705 Modular: Extractors are pluggable (add new ones without touching scoring logic)</p> <p>\u2705 Auditable: Every computation logged with full feature snapshot + model version</p> <p>\u2705 Interpretable: Linear scorecard explains which factors matter most</p> <p>\u2705 Extensible: ML model support via <code>model_registry</code> (plug in any model)</p> <p>\u2705 Robust: Fallback from Postgres to SQLite, error handling in extractors</p> <p>\u2705 Scalable: Stateless API (can run multiple instances), database-backed persistence</p>"},{"location":"#next-steps-future-work","title":"Next Steps &amp; Future Work","text":"<ul> <li>[ ] Add Alembic migrations for schema versioning</li> <li>[ ] Implement ML scoring option (XGBoost, Neural Network) in model_registry</li> <li>[ ] Add data validation rules for incoming transactions</li> <li>[ ] Build admin dashboard for model/rule management</li> <li>[ ] Add webhooks for score change notifications</li> <li>[ ] Implement feature importance explainability (SHAP values)</li> <li>[ ] Add API rate limiting and authentication (OAuth2)</li> <li>[ ] Deploy to cloud (AWS ECS, GCP Cloud Run, Azure Container Instances)</li> </ul>"}]}